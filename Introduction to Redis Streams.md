# Redis Stream 介绍
[官网原文链接](https://redis.io/topics/streams-intro)

stream是Redis5.0新加入的数据类型，它定义了一种更抽象的*日志数据类型*，然而日志的本质还是完整的：就像一个日志文件一样，总是以append only的方式操作。Redis的stream就是一种append only的数据类型。至少从概念上来说，因为Redis的stream是基于内存的一种抽象数据类型，它可以突破基于硬盘的日志文件限制，实现更强大的操作。

是什么让stream成为了Redis最复杂的数据类型？尽管这种数据结构本身很简单，它实现了可选择的，无强制性的特性：一套阻塞操作允许消费者等待生产者新添加到stream的数据，除此之外引入了一个新的概念叫做**消费者组(Consumer Groups)**

消费者组最开始是在一个非常受欢迎的消息系统Kafka(TM)中被引入的。Redis用一个完全不同的实现重现了这个概念：使得一组不同的客户端可以操作同样一个数据流的不同部分。

## Stream基础

为了更好地理解Redis的stream的概念和使用，我们先忽略全部的高级特性然后专注于数据结构本身，我们按照一系列命令和操作来熟悉他。基本上，大部分性质和Redis其他数据类型一致，如List, Sets, Sorted Sets等等。然而list也有一套更加复杂的阻塞API，通过BLPOP或其他命令实现。所以stream在这方面和list没有太大区别，仅仅是这套阻塞API更加强大和复杂。

因为stream是append only的数据结构，最基本的写入命令叫做**XADD**，向指定stream中添加一个新条目(entry)。一个stream条目不仅仅是字符串，而是一个或多个键值对构成。通过这种方式，stream中每一个条目都是结构化的，就像CSV格式的追加文件一样，每行中都有多个分割开的字段。(译者：右键csv用文本文档打开，可以开到csv每行的值是通过逗号分隔的。)
```
> XADD mystream * sensor-id 1234 temperature 19.8
1518951480106-0
```
上述代码调用了XADD命令向key值为mystream的stram中添加了一个条目 sensor-id 1234 temperature 19.8，使用了一个自动生成的ID，这是命令返回的值，在这里为1518951480106-0。上述代码得到第一个参数为key的名字mystream，第二个参数为条目ID，这个ID是在每个stream内部定义的。在这个例子里我们传递\*因为我们想让服务器为我们生成一个新的ID。每个新的ID都会单调递增，所以新添加的条目的ID肯定会比之前的条目大。服务器自动生成ID是你经常要用到的，需要指定ID的情况非常少见，我们之后再谈。总的来说，每一个stream条目都有一个ID，这和日志文件很像。回到**XADD**的例子，在key的名字和ID之后，下一个参数是我们要写入的键值对。
通过**XLEN**命令来得到一个stream中的条目总数：
```
> XLEN mystream
(integer) 1
```
## 条目ID
**XADD**命令返回条目ID，该ID可以精准识别stream中的每一个条目，它由两部分组成：
```
<millisecondsTime>-<sequenceNumber>
```
毫秒(millisecondsTime)部分是Redis节点本地的时钟时间，然而如果现在的毫秒时间小于之前的条目时间，那么会使用之前的条目时间代替，所以如果时钟向前回调的话，单调递增的ID仍然会生效。序列号用于在相同毫秒内创建的条目。由于序列号是64位，所以在实际应用中，在相同毫秒内生成的条目没有数量限制。

刚开始看你可能会感觉这种ID格式很奇怪，你也可能会为为什么时间是ID的一部分而感到困惑。（译者：当你熟练掌握后你就会感觉这种数据结构强的一比！（破音））原因是Redis stream支持通过ID进行范围查询。因为ID是可以和条目生成的时间相关联，这就让stream有了基于时间范围查询的能力。我们过会会看到通过**XRANGE**命令。

出于某些原因，用户不想使用基于时间的ID也是可以的。**XADD**命令可以使用明确的ID来代替\*，就像下面的例子一样：
```
> XADD somestream 0-1 field value
0-1
> XADD somestream 0-2 foo bar
0-2
```
在这个例子中，最小的ID为0-1并且这个命令不会接受小于或等于之前ID的值：
```
> XADD somestream 0-1 foo bar
(error) ERR The ID specified in XADD is equal or smaller than the target stream top item
```

## 从Stream中获取数据
现在我们可以通过**XADD**向stream中添加数据了。向stream中添加数据看起来很清晰很明确，然而stream提取数据的方式看起来并不是很清晰了。如果我们继续类比日志文件的话，比较清晰的表达方式是我们模仿Unix命令tail -f，这样我们可以开始监听新添加到stream中的信息。注意和Redis的list阻塞操作不同，list阻塞操作只允许一个客户端获取到一个元素，通过阻塞的*pop类型*操作例如**BLPOP**，在stream中全部的消费者都可以看到新添加进stream中的信息，就像很多个tail -f进程一起看日志里写入了什么一样。用专业术语来说我们想让stream可以*扇出(fan out)*到多个客户端。

然而这只是一种潜在的访问模式。我们还可以这样看待stream：不作为一个消息系统，而作为*时间序列存储*。这样可能有助于获取到新append进来的信息，另一种更自然的查询模式是通过时间序列查询信息，或者说使用一个游标来迭代全部历史信息。这是另一种有效的访问模式。

最后，如果我们以消费者的视角来看stream，我们可能想通过另外一种方式访问stream，作为消息流可以将其划分给处理此消息的多个消费者，所以各个组的消费者只能看到消息流中的一个子集。这样就可以将消息划分给不同的消费者，不再需要单个消费者处理全部的消息：每个消费者仅仅得到需要处理的信息。这就是Kafka(TM)使用消费者组实现的。通过消费者组读取消息是从Redis stream中读取信息的一种有趣的模式。

Redis stream使用不同命令来支持上述三种查询模式。下一章会全部展示这三种方法，让我们从最简单最直接的方式开始：范围查询。(range queries)

## 通过范围查询：XRANGE和XREVRANGE
通过范围查询stream我们需要指定两个ID，*起始ID和结束ID*。返回会包含起始ID和结束ID之间的信息。两个特殊的ID-和+代表最小和最大的ID。
```
> XRANGE mystream - +
1) 1) 1518951480106-0
   2) 1) "sensor-id"
      2) "1234"
      3) "temperature"
      4) "19.8"
2) 1) 1518951482479-0
   2) 1) "sensor-id"
      2) "9999"
      3) "temperature"
      4) "18.2"
```
返回的每个条目是包含两项的数组：ID和键值对的list。我们已经知道ID是和时间关联的，因为左边的部分是stream条目创建时的本地节点的Unix毫秒时间，在那一刻条目被创建（注意stream通过XADD命令被复制，所以集群的slaves对于master有可识别的ID）。这意味着我可以使用**XRANGE**来查询一个时间段。为了这样做，我想省略掉ID的序列部分：如果这个字段被省略，range的起始部分假设序列为0，在末尾会假设序列ID为可以取的最大值。使用两个时间来进行查询，我们能得到在这个时间段内生成的条目。举个例子，我想查询两个时间点之间写入的值：
```
> XRANGE mystream 1518951480106 1518951480107
1) 1) 1518951480106-0
   2) 1) "sensor-id"
      2) "1234"
      3) "temperature"
      4) "19.8"
```
这里我只有一条数据，然而在真实数据集中我可以查询几个小时的范围内写入的值，这个数据体量会很大。因为数据量可能会很大，所以**XRANGE**支持一个可选的参数**COUNT**。通过制定一个count，你可以得到前N条数据。如果我想获取更多，我可以取出上一次返回值的最后的ID然后将其作为起始时间继续查询。我们看下面的例子来实现这个功能。我们先使用**XADD**命令添加十条数据（这步自己做，mystream这个stream确保有十条数据）。现在启动迭代，每次命令取出两条数据，我先从全部范围开始查询，但是count设为2。
```
> XRANGE mystream - + COUNT 2
1) 1) 1519073278252-0
   2) 1) "foo"
      2) "value_1"
2) 1) 1519073279157-0
   2) 1) "foo"
      2) "value_2"
```
**XRANGE**的复杂度是O(log(N))，然后O(M)返回M个元素，当count的值较小时这个命令的时间复杂度是对数，这意味着每一步迭代都非常快。所以**XRANGE**实际上就是stream的迭代器并不需要**XSCAN**命令。

**XREVRANGE**功能等同于**XRANGE**但是返回的元素是倒序的，所以经常使用**XREVRANGE**来查看stream中最后的元素是什么：
```
> XREVRANGE mystream + - COUNT 1
1) 1) 1519073287312-0
   2) 1) "foo"
      2) "value_10"
```
请注意**XREVRANGE**命令的起始和结束位参数也要是倒序的。

## 使用**XREAD**命令来监听新的数据

当我们不想通过范围来访问stream中的数据时，通常来说我们*订阅*到达stream中的新数据。这个概念与Redis Pub/Sub有关联，当你订阅了一个channel或者Redis阻塞list，你等待一个key来获取新元素，但是你消费stream时会有几个本质的区别：

1. stream可以有多个等待数据的客户端（消费者）。每次新的数据达到，默认情况下会被分发到这个stream中等待消息的*全部消费者*。该行为和阻塞list不同，阻塞list的每个消费者会收到不同的数据。然鹅*扇出*到多个消费者与Pub/Sub很像。
2. 就像Pub/Sub中消息的fire和forget和永不存储一样，使用阻塞list时当消息被客户端poped接收后会从list中删除，stream的工作方式完全不同。所有的消息被无限地添加进steam中（除非用户明确要删除数据）：不同的消费者通过记住最后收到的消息ID来识别那些新的消息。
3. stream消费者组提供了一个Pub/Sub或者阻塞list无法触及的控制水平，在同一stream中不同的消费组，显式地确认已经处理的数据，检查待处理的数据的能力，声明不处理的消息，以及每个客户端拥有一致的历史可见性，只能查看自己私有的消息历史。

**XREAD**命令提供监听到达stream的新消息的能力。它比**XRANGE**复杂一点，所以我们先从简单的形式开始，之后会介绍整个命令的格式。
```
> XREAD COUNT 2 STREAMS mystream 0
1) 1) "mystream"
   2) 1) 1) 1519073278252-0
         2) 1) "foo"
            2) "value_1"
      2) 1) 1519073279157-0
         2) 1) "foo"
            2) "value_2"
```
上述命令是**XREAD**的非阻塞格式。**COUNT**是可选的，唯一强制参数是STREAMS，他指定一个键列表，以及一个消费者在steam中的ID以便客户端只接收那些拥有更大ID的消息。

上述命令我们写入STREAMS mystream 0所以我们想要在mystream中ID比0-0大的信息。上述命令返回了key的名字，这是因为实际上可以调用这个命令同时从超过一个stream中读取数据。举个例子，可以这样写：STREAMS mystream otherstream 0 0。需要注意的是在STREAMS选项后我们要提供key的名字和ID。所以STREAMS选项必须永远在命令的末尾。

