# Redis Stream 介绍
[官网原文链接](https://redis.io/topics/streams-intro)

stream是Redis5.0新加入的数据类型，它定义了一种更抽象的*日志数据类型*，然而日志的本质还是完整的：就像一个日志文件一样，总是以append only的方式操作。Redis的stream就是一种append only的数据类型。至少从概念上来说，因为Redis的stream是基于内存的一种抽象数据类型，它可以突破基于硬盘的日志文件限制，实现更强大的操作。

是什么让stream成为了Redis最复杂的数据类型？尽管这种数据结构本身很简单，它实现了可选择的，无强制性的特性：一套阻塞操作允许消费者等待生产者新添加到stream的数据，除此之外引入了一个新的概念叫做**消费者组(Consumer Groups)**

消费者组最开始是在一个非常受欢迎的消息系统Kafka(TM)中被引入的。Redis用一个完全不同的实现重现了这个概念：使得一组不同的客户端可以操作同样一个数据流的不同部分。

## Stream基础

为了更好地理解Redis的stream的概念和使用，我们先忽略全部的高级特性然后专注于数据结构本身，我们按照一系列命令和操作来熟悉他。基本上，大部分性质和Redis其他数据类型一致，如List, Sets, Sorted Sets等等。然而list也有一套更加复杂的阻塞API，通过BLPOP或其他命令实现。所以stream在这方面和list没有太大区别，仅仅是这套阻塞API更加强大和复杂。

因为stream是append only的数据结构，最基本的写入命令叫做**XADD**，向指定stream中添加一个新条目(entry)。一个stream条目不仅仅是字符串，而是一个或多个键值对构成。通过这种方式，stream中每一个条目都是结构化的，就像CSV格式的追加文件一样，每行中都有多个分割开的字段。(译者：右键csv用文本文档打开，可以开到csv每行的值是通过逗号分隔的。)
```
> XADD mystream * sensor-id 1234 temperature 19.8
1518951480106-0
```
上述代码调用了XADD命令向key值为mystream的stram中添加了一个条目 sensor-id 1234 temperature 19.8，使用了一个自动生成的ID，这是命令返回的值，在这里为1518951480106-0。上述代码得到第一个参数为key的名字mystream，第二个参数为条目ID，这个ID是在每个stream内部定义的。在这个例子里我们传递\*因为我们想让服务器为我们生成一个新的ID。每个新的ID都会单调递增，所以新添加的条目的ID肯定会比之前的条目大。服务器自动生成ID是你经常要用到的，需要指定ID的情况非常少见，我们之后再谈。总的来说，每一个stream条目都有一个ID，这和日志文件很像。回到**XADD**的例子，在key的名字和ID之后，下一个参数是我们要写入的键值对。
通过**XLEN**命令来得到一个stream中的条目总数：
```
> XLEN mystream
(integer) 1
```
## 条目ID
**XADD**命令返回条目ID，该ID可以精准识别stream中的每一个条目，它由两部分组成：
```
<millisecondsTime>-<sequenceNumber>
```
毫秒(millisecondsTime)部分是Redis节点本地的时钟时间，然而如果现在的毫秒时间小于之前的条目时间，那么会使用之前的条目时间代替，所以如果时钟向前回调的话，单调递增的ID仍然会生效。序列号用于在相同毫秒内创建的条目。由于序列号是64位，所以在实际应用中，在相同毫秒内生成的条目没有数量限制。

刚开始看你可能会感觉这种ID格式很奇怪，你也可能会为为什么时间是ID的一部分而感到困惑。（译者：当你熟练掌握后你就会感觉这种数据结构强的一比！（破音））原因是Redis stream支持通过ID进行范围查询。因为ID是可以和条目生成的时间相关联，这就让stream有了基于时间范围查询的能力。我们过会会看到通过**XRANGE**命令。

出于某些原因，用户不想使用基于时间的ID也是可以的。**XADD**命令可以使用明确的ID来代替\*，就像下面的例子一样：
```
> XADD somestream 0-1 field value
0-1
> XADD somestream 0-2 foo bar
0-2
```
在这个例子中，最小的ID为0-1并且这个命令不会接受小于或等于之前ID的值：
```
> XADD somestream 0-1 foo bar
(error) ERR The ID specified in XADD is equal or smaller than the target stream top item
```

## 从Stream中获取数据
现在我们可以通过**XADD**向stream中添加数据了。向stream中添加数据看起来很清晰很明确，然而stream提取数据的方式看起来并不是很清晰了。如果我们继续类比日志文件的话，比较清晰的表达方式是我们模仿Unix命令tail -f，这样我们可以开始监听新添加到stream中的信息。注意和Redis的list阻塞操作不同，list阻塞操作只允许一个客户端获取到一个元素，通过阻塞的*pop类型*操作例如**BLPOP**，在stream中全部的消费者都可以看到新添加进stream中的信息，就像很多个tail -f进程一起看日志里写入了什么一样。用专业术语来说我们想让stream可以*扇出(fan out)*到多个客户端。

然而这只是一种潜在的访问模式。我们还可以这样看待stream：不作为一个消息系统，而作为*时间序列存储*。这样可能有助于获取到新append进来的信息，另一种更自然的查询模式是通过时间序列查询信息，或者说使用一个游标来迭代全部历史信息。这是另一种有效的访问模式。

最后，如果我们以消费者的视角来看stream，我们可能想通过另外一种方式访问stream，作为消息流可以将其划分给处理此消息的多个消费者，所以各个组的消费者只能看到消息流中的一个子集。这样就可以将消息划分给不同的消费者，不再需要单个消费者处理全部的消息：每个消费者仅仅得到需要处理的信息。这就是Kafka(TM)使用消费者组实现的。通过消费者组读取消息是从Redis stream中读取信息的一种有趣的模式。

Redis stream使用不同命令来支持上述三种查询模式。下一章会全部展示这三种方法，让我们从最简单最直接的方式开始：范围查询。(range queries)

## 通过范围查询：XRANGE和XREVRANGE
通过范围查询stream我们需要指定两个ID，*起始ID和结束ID*。返回会包含起始ID和结束ID之间的信息。两个特殊的ID-和+代表最小和最大的ID。
```
> XRANGE mystream - +
1) 1) 1518951480106-0
   2) 1) "sensor-id"
      2) "1234"
      3) "temperature"
      4) "19.8"
2) 1) 1518951482479-0
   2) 1) "sensor-id"
      2) "9999"
      3) "temperature"
      4) "18.2"
```
返回的每个条目是包含两项的数组：ID和键值对的list。我们已经知道ID是和时间关联的，因为左边的部分是stream条目创建时的本地节点的Unix毫秒时间，在那一刻条目被创建（注意stream通过XADD命令被复制，所以集群的slaves对于master有可识别的ID）。这意味着我可以使用**XRANGE**来查询一个时间段。为了这样做，我想省略掉ID的序列部分：如果被省略，range的起始部分假设序列为0，在末尾会假设序列ID为可以取的最大值。

